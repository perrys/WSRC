#!/usr/bin/env python
# -*- coding: utf-8 -*-

import datetime
import getopt
import logging
import os
import os.path
import sys

import markdown
import wsrc.site.settings.settings as settings
from wsrc.utils import sync_utils
import wsrc.utils.timezones as timezone_utils
LOGGER = logging.getLogger(__name__)
LOGGER.setLevel(logging.INFO)

import wsrc.utils.email_utils as email_utils
from django.template import Template, Context
from django.db import transaction
from wsrc.utils.text import formatTable as format_text_table
from wsrc.utils.html_table import formatTable as format_html_table

COMMITTEE_EMAIL_ADDRESS = "committee@wokingsquashclub.org"
TOURNAMENTS_EMAIL_ADDRESS = "tournaments@wokingsquashclub.org"
MEMBERSHIP_EMAIL_ADDRESS = "membership@wokingsquashclub.org"

def manage_tournament_bookings(username, password):

    ADVANCE_BOOKING_DAYS = 10
    RELEASE_BOOKING_DAYS = 2
    TARGET_SLOTS         = [(datetime.time(18, 15), 2), (datetime.time(19, 0), 2)]
    TARGET_DAYS          = [0,1,2,3] # monday - thursday
    TARGET_DESCRIPTION   = "Unreserved - will be released 2 days in advance"
    TARGET_NAME          = "Tournament Matches"

    today = datetime.date.today()
    target_date = today + datetime.timedelta(days=ADVANCE_BOOKING_DAYS)
    from wsrc.external_sites.booking_manager import BookingSystemSession
    session = BookingSystemSession(username, password)

    if target_date.weekday() in TARGET_DAYS:
        for time, court in TARGET_SLOTS:
            try:
                date_and_time = datetime.datetime.combine(target_date, time)
                LOGGER.info("Booking tournament court @ {0}".format(date_and_time.isoformat()))
                session.make_admin_booking(target_date, time, 45, court, TARGET_NAME, TARGET_DESCRIPTION, "E")
            except Exception:
                LOGGER.exception("unable to book court")

    booking_events, start_date = session.get_booked_courts(today)
    for evt in booking_events:
        ndays = (evt.start_time.date() - today).days
        if ndays > 0 and ndays <= RELEASE_BOOKING_DAYS:
            if evt.name.lower().find("tournament") >= 0:
                if evt.description.lower().find("unreserved") >= 0:
                    LOGGER.info("deleting booking id {0}, time: {1}, name: \"{2}\", description: \"{3}\"".format(evt.event_id,
                                                                                                                 evt.start_time.isoformat(" "),
                                                                                                                 evt.name,
                                                                                                                 evt.description))
                    session.delete_booking(evt.event_id)

def email_report_overdue_tournament_matches():
    import wsrc.site.competitions.tournament as tournament_utils
    import wsrc.site.models as site_models;
    import wsrc.site.competitions.models as comp_models;

    today = datetime.date.today()
    def is_overdue(match):
        return match.get_deadline() < today

    current_tournaments = tournament_utils.get_current_competitions()
    overdue_match_map = dict()
    for tournament in current_tournaments:
        matches = tournament_utils.get_unplayed_matches(tournament)
        overdue_matches = [m for m in matches if is_overdue(m)]
        overdue_matches.sort(key=lambda(x): x.get_deadline(), reverse=False)
        if len(overdue_matches) > 0:
            overdue_match_map[tournament] = overdue_matches

    def get_opponent_desc(match, team_number_1_or_2):
        opponents = match.get_team(team_number_1_or_2)
        if opponents is not None:
            return opponents.get_players_as_string()
        def match_descr(match, team_number):
            try:
                previous_match = tournament_utils.get_previous_match(match, team_number)
                t1 = previous_match.team1 is not None and previous_match.team1.get_players_as_string() or match_descr(previous_match, 1)
                t2 = previous_match.team2 is not None and previous_match.team2.get_players_as_string() or match_descr(previous_match, 2)
                return "(WINNER of %(t1)s vs %(t2)s)" % locals()
            except comp_models.Match.DoesNotExist: # if opponents are two rounds behind
                return "(PREVIOUS MATCH UNRESOLVED)"
        return match_descr(match, team_number_1_or_2)

    for tournament, overdue_matches in overdue_match_map.iteritems():
        match_table = [["Comp", "Match", "Deadline"]]
        for match in overdue_matches:
            t1 = get_opponent_desc(match, 1)
            t2 = get_opponent_desc(match, 2)
            match_table.append([tournament.name, "%(t1)s vs %(t2)s" % locals(), match.get_deadline().strftime("%a %d %b")])
        overdue_match_map[tournament] = {
            "raw_data": match_table,
            "text/plain": format_text_table(match_table, hasHeader=True, nspaces=2),
            "text/html":  format_html_table(match_table, hasHeader=True),
            }

    context = Context({"tournaments": overdue_match_map, "today": today})
    text_body, html_body = email_utils.get_email_bodies("Overdue Tournament Matches", context)
    subject = "Overdue Match Report".format(**locals())
    from_address = TOURNAMENTS_EMAIL_ADDRESS
    to_list = [TOURNAMENTS_EMAIL_ADDRESS]
    email_utils.send_email(subject, text_body, html_body, from_address, to_list)

def email_outstanding_box_matches():
    import wsrc.site.competitions.tournament as tournament_utils
    import wsrc.site.competitions.models as comp_models;
    import wsrc.site.models as site_models;

    boxes_group = comp_models.CompetitionGroup.objects.filter(comp_type="wsrc_boxes").get(active=True)
    boxes = [c for c in boxes_group.competition_set.all()]
    email_template = site_models.EmailContent.objects.get(name="EndOfLeagueReminder")
    email_template = Template(email_template.markup)

    for box in boxes:
        matches = tournament_utils.get_unplayed_matches(box)
        opponent_set = set()
        for match in matches:
            opponent_set.add(match.get_team(1))
            opponent_set.add(match.get_team(2))

        to_list = [entrant.player1.user.email for entrant in opponent_set]

        context = Context({
          "competition": box,
          "opponents": opponent_set,
          "matches": matches
        })
        context["content_type"] = "text/html"
        html_body = markdown.markdown(email_template.render(context))
        context["content_type"] = "text/plain"
        text_body = email_template.render(context)
        subject = "WSRC {box_name} Box Ending {date:%a %d %b}".format(box_name=box.name, date=box.end_date)
        from_address = "leagues@wokingsquashclub.org"

        email_utils.send_email(subject, text_body, html_body, from_address, to_list)



def email_tournament_match_reminders(usernames):
    import wsrc.site.competitions.models as comp_models;
    import wsrc.site.competitions.tournament as tournament_utils
    import wsrc.site.models as site_models;
    import wsrc.site.usermodel.models as user_models;
    import wsrc.utils.collection_utils as collection_utils

    current_tournaments = tournament_utils.get_current_competitions()
    year = datetime.date.today().year

    # Populate map of player_id -> unplayed matches
    player_to_matches_map = {}
    for tournament in current_tournaments:
        for m in tournament_utils.get_unplayed_matches(tournament):
            for i in [1,2]:
                entrant = getattr(m, "team%(i)d" % locals())
                if not entrant:
                    continue
                for player in entrant.get_players():
                    match_list = collection_utils.get_or_add(player_to_matches_map, player.id)
                    match_list.append(m)

    # for each player/match_list combination, create rectangular tables
    # of match descriptions and opponent details
    player_to_opponent_table_map = dict()
    player_to_match_table_map = dict()
    for player_id, match_list in player_to_matches_map.iteritems():
        player = user_models.Player.objects.get(pk=player_id)
        match_rows = [["Comp [Round]", "Opponent(s)", "Deadline", "Link"]]
        opponent_set = set()
        for match in match_list:
            my_team_number = tournament_utils.get_team_number(match, player_id)
            other_team_number = tournament_utils.other_team_number(my_team_number)
            opponents = match.get_team(other_team_number)
            if opponents is not None:
                opponent_set.update(opponents.get_players())
                opponent_desc = opponents.get_players_as_string()
            else:
                def match_descr(match, team_number):
                    try:
                        previous_match = tournament_utils.get_previous_match(match, team_number)
                        t1 = previous_match.team1 is not None and previous_match.team1.get_players_as_string() or match_descr(previous_match, 1)
                        t2 = previous_match.team2 is not None and previous_match.team2.get_players_as_string() or match_descr(previous_match, 2)
                        return "(WINNER of %(t1)s vs %(t2)s)" % locals()
                    except comp_models.Match.DoesNotExist: # if opponents are two rounds behind
                        return "(PREVIOUS MATCH UNRESOLVED)"
                opponent_desc = match_descr(match, other_team_number)

            if match.is_knockout_comp():
                comp_name  = match.competition.name
                comp_round = match.get_round()
                nrounds    = len(match.competition.rounds.all())
                n = 1+nrounds-comp_round.round
                comp_round = str(comp_round.round)
                if n == 1:
                    comp_round = "F"
                elif n == 2:
                    comp_round = "SF"
                elif n == 3:
                    comp_round = "QF"
            else:
                end_date   = match.competition.end_date
                comp_round = match.competition.name
                comp_name  = match.competition.group.name.replace("Qualifiers - ", "")
                comp_name  = comp_name.replace(str(end_date.year), "").strip()
            match_rows.append([comp_name + " [" + comp_round + "]", opponent_desc, match.get_deadline().strftime("%a %d %b"), match.competition.url])
        opponent_rows = [["Name", "Email", "Telephone", "Mobile"]]
        for opponent in opponent_set:
            opponent_rows.append([opponent.user.get_full_name(), opponent.user.email, opponent.other_phone, opponent.cell_phone])
        player_to_match_table_map[player_id] = match_rows
        player_to_opponent_table_map[player_id] = opponent_rows

    # now iterate over the players and construct emails using these tables
    email_template = site_models.EmailContent.objects.get(name="Tournament Reminder")
    email_template = Template(email_template.markup)
    failed_players = []
    for player_id in player_to_match_table_map.iterkeys():
        p = user_models.Player.objects.get(pk=player_id)
        match_table = player_to_match_table_map[player_id]
        opponent_table = player_to_opponent_table_map[player_id]
        context = Context({
          "player": p,
          "year": year,
          "match_table": {
            "raw_data": match_table,
            "text/plain": format_text_table(match_table, hasHeader=True, nspaces=2),
            "text/html":  format_html_table(match_table, hasHeader=True),
            },
          "opponent_table": {
            "raw_data":   opponent_table,
            "text/plain": format_text_table(opponent_table, hasHeader=True, nspaces=2),
            "text/html":  format_html_table(opponent_table, hasHeader=True, col_prefixes=["", "mailto:", "tel:", "sms:"]),
            },
          "content_type": "text/html"
          })
        if usernames == [] or p.user.username in usernames:
            if p.user.email.find('@') > 0:
                subject = "{year} Tournaments".format(**locals())
                from_address = TOURNAMENTS_EMAIL_ADDRESS
                html_body = markdown.markdown(email_template.render(context))
                context["content_type"] = "text/plain"
                text_body = email_template.render(context)
                to_list = [p.user.email]
                try:
                    email_utils.send_email(subject, text_body, html_body, from_address, to_list)
                except:
                    failed_players.append(p)
                    import traceback
                    traceback.print_exc()
                email_utils.pause_between_emails()
            else:
                sys.stderr.write("WARNING: no email address for " + p.get_full_name())
        if len(failed_players) > 0:
            sys.stderr.write("ERROR: failed to send email to the following:\n" + "\n".join([p.get_full_name() + " " + p.user.email for p in failed_players]) + "\n")

def email_subscription_reminders(user_list):
    import wsrc.site.usermodel.models as user_models;
    import wsrc.site.models as site_models;
    seasons = user_models.Season.objects.exclude(has_ended=True)
    last_season = seasons.first()
    this_season = seasons.last()
    subs = user_models.Subscription.objects.filter(season=last_season).exclude(subscription_type__name__icontains="*")\
                                                                      .select_related("player__user", "subscription_type")
    new_subs = user_models.Subscription.objects.filter(season=this_season).exclude(subscription_type__name__icontains="*")\
                                                                      .select_related("player__user", "subscription_type")
    already_subscribed = set()
    for sub in new_subs:
        already_subscribed.add(sub.player)

    costs = user_models.SubscriptionCost.objects.filter(season=this_season).exclude(subscription_type__name__icontains="*")\
                                                                           .select_related("subscription_type")
    emails = dict()
    for sub in subs:
        if not sub.player.is_active:
            continue
        if sub.player in already_subscribed:
            continue
        if user_list and sub.player.user.email not in user_list:
            continue
        email = sub.player.user.email
        costs = [cost for cost in costs if cost.subscription_type == sub.subscription_type]
        if len(costs) > 0 and cost.amount > 0 and email and email.find('@') > 0:
            subs_for_email = emails.setdefault(email, [])
            subs_for_email.append(sub)
    LOGGER.info("found %d unique email addresses with current subscriptions", len(emails))
    # todo - sort email lists in order of seniority
    email_template = site_models.EmailContent.objects.get(name="Subscription Reminder")
    email_template = Template(email_template.markup)
    email_keys = emails.keys()
    email_keys.sort()
    failed_players = list()
    for email in email_keys:
        player = emails[email][0].player
        context = Context({
            "subscriptions": emails[email],
            "player": player,
            "costs": costs,
            "content_type": "text/html"
        })
        subject = "{this_season} Subscriptions".format(**locals())
        from_address = MEMBERSHIP_EMAIL_ADDRESS
        html_body = markdown.markdown(email_template.render(context), extensions=['markdown.extensions.extra'])
        context["content_type"] = "text/plain"
        text_body = email_template.render(context)
        to_list = [email]
        try:
            email_utils.send_email(subject, text_body, html_body, from_address, to_list)
        except:
            failed_players.append(player)
            import traceback
            traceback.print_exc()
        email_utils.pause_between_emails()
    LOGGER.info("emails sent")
    if len(failed_players) > 0:
        LOGGER.error("failed to send email to the following:\n\n%s", "\n".join([p.get_full_name() + " " + p.user.email for p in failed_players]) + "\n")

def download_met_office_data():
    from wsrc.external_sites.met_office import fetch_and_store_distance_weigted_average_observations
    obs_locations = [l[0] for l in settings.MET_OFFICE_OBSERVATION_LOCATIONS]
    fetch_and_store_distance_weigted_average_observations(settings.CLUB_LOCATION, *obs_locations)

@transaction.atomic
def book_courts(date, courts, times, duration, event_type, name, description):
    import wsrc.site.courts.models as court_models;
    import django.contrib.auth.models as auth_models;
    admin_user = auth_models.User.objects.get(username="admin")

    LOGGER.info("booking %d court(s), name=%s", len(courts), name)
    for court,time in zip(courts, times):
        start_time = datetime.datetime.combine(date, time)
        start_time = start_time.replace(tzinfo=timezone)
        end_time = start_time + duration
        model = court_models.BookingSystemEvent(start_time=start_time, end_time=end_time, court=court,
                                     name=name, description=description, event_type=event_type,
                                     created_by_user=admin_user, last_updated_by=admin_user)
        model.validate_unique([])
        model.save()
    
if __name__ == "__main__":
    prog = os.path.basename(sys.argv[0])

    if len(sys.argv) < 2:
        sys.stderr.write("USAGE: %(prog)s <command> [arguments]\n" % locals())
        sys.exit(1)

    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "wsrc.site.settings.settings")
    logging.basicConfig(format='%(asctime)-10s [%(levelname)s] %(message)s',datefmt="%Y-%m-%d %H:%M:%S")

    import django
    if hasattr(django, "setup"):
        django.setup()

    import wsrc.external_sites.main
    import wsrc.external_sites.mailchimp

    command = sys.argv[1]
    args = sys.argv[2:]
    if command in ("sync", "sync-bookings"):
        wsrc.external_sites.main.cmdline_sync_bookings()

    elif command in ("sync-squashlevels"):
        wsrc.external_sites.main.cmdline_sync_squashlevels(*args)

    elif command in ("sync-leaguemaster"):
        wsrc.external_sites.main.cmdline_sync_leaguemaster(*args)

    elif command in ("sync-mailchimp"):
        wsrc.external_sites.mailchimp.sync()

    elif command in ("manage-tournament-bookings"):

        def usage():
            prog = os.path.basename(sys.argv[0])
            sys.stderr.write("USAGE: %s %s --username=<user> --password=<pw>\n" % (prog, sys.argv[1]))
        try:
            optlist, args = getopt.getopt(args, "u:p:h", ["username=", "password="])
        except getopt.GetoptError as err:
            sys.stderr.write(str(err) + "\n")
            usage()
            sys.exit(2)

        username = password = None
        for opt,val in optlist:
            if opt in ["-u", "--username"]:
                username = val
            elif opt in ["-p", "--password"]:
                password = val
            elif opt in ["-h"]:
                usage()
                sys.exit(0)
            else:
                assert False, "unhandled option"

        if username is None or password is None:
            usage()
            sys.exit(1)

        manage_tournament_bookings(username, password)

    elif command in ("send-tournament-reminders"):
        def usage():
            sys.stderr.write("USAGE: %s %s --username <username>|--all\n" % (prog, command))
        try:
            optlist, args = getopt.getopt(sys.argv[2:], "au:", ["all", "username="])
        except getopt.GetoptError as err:
            sys.stderr.write(str(err) + "\n")
            usage()
            sys.exit(2)

        user_list = None
        for opt,val in optlist:
            if opt in ["-a", "--all"]:
                user_list = []
            elif opt in ["-u", "--username"]:
                user_list = [val]

        if user_list is None:
            usage()
            sys.exit(2)

        email_tournament_match_reminders(user_list)

    elif command in ("send-overdue-match-report"):
        email_report_overdue_tournament_matches()

    elif command in ("send-outstanding-league-match-reminders"):
        email_outstanding_box_matches()

    elif command in ("send-subscription-reminders"):
        try:
            optlist, args = getopt.getopt(sys.argv[2:], "au:", ["all", "username="])
        except getopt.GetoptError as err:
            sys.stderr.write(str(err) + "\n")
            usage()
            sys.exit(2)

        user_list = None
        for opt,val in optlist:
            if opt in ["-a", "--all"]:
                user_list = []
            elif opt in ["-u", "--username"]:
                user_list = [val]

        if user_list is None:
            usage()
            sys.exit(2)

        email_subscription_reminders(user_list)

    elif command in ("add-old-league"):
        wsrc.external_sites.main.cmdline_add_old_league(args)

    elif command in ("monitor_bookings"):
        def usage():
            sys.stderr.write("USAGE: %s %s [--date=<YYYY-MM-DD>] [--ndays=<n>]\n" % (prog, command))
        try:
            optlist, args = getopt.getopt(sys.argv[2:], "d:n:", ["date=", "ndays="])
        except getopt.GetoptError as err:
            sys.stderr.write(str(err) + "\n")
            usage()
            sys.exit(2)

        date = (datetime.datetime.now() - datetime.timedelta(days=1)).date()
        ndays = 1

        user_list = None
        for opt,val in optlist:
            if opt in ["-d", "--date"]:
                date = timezone_utils.parse_iso_date_to_naive(val)
            elif opt in ["-n", "--ndays"]:
                ndays = int(val)

        from wsrc.external_sites.booking_monitor import process_date
        while ndays > 0:
            process_date(date)
            date = date + datetime.timedelta(days=1)
            ndays -= 1
            
    elif command in ("create-bookings"):
        def usage():
            sys.stderr.write("USAGE: {prog} {command} --name=<name> [--description=<description>] --advancedays=<ndays> " +
                             "--courts=<n1,n2..> --times=<t1,t2..> --duration=<nminutes> [--type=<I|E>]\n".format(**locals()))
        try:
            optlist, args = getopt.getopt(sys.argv[2:], "a:c:t:d", ["advancedays=", "courts=", "times=", "duration=", "name=", "description=", "type="])
        except getopt.GetoptError as err:
            sys.stderr.write(str(err) + "\n")
            usage()
            sys.exit(2)
        timezone = timezone_utils.UK_TZINFO
        date = None
        duration = None
        courts = []
        times = []
        booking_type = "E"
        name = None
        description = None
        for opt,val in optlist:
            if opt in ["-a", "--advancedays"]:
                date = datetime.date.today() + datetime.timedelta(days=int(val))
            elif opt in ["-c", "--courts"]:
                courts = [int(v) for v in val.split(",")]
            elif opt in ["-t", "--times"]:
                times = [datetime.datetime.strptime(v, "%H:%M").time() for v in val.split(",")]
            elif opt in ["-d", "--duration"]:
                duration = datetime.timedelta(minutes=int(val))
            elif opt in ["--type"]:
                booking_type = val[0]
            elif opt in ["--name"]:
                name = val
            elif opt in ["--description"]:
                description = val
        if name is None or date is None or duration is None or len(courts) != len(times):
            usage()
            sys.exit(1)
        book_courts(date, courts, times, duration, booking_type, name, description)
                

    elif command in ("purge-personal-data"):
        from wsrc.site.usermodel.data_purge import policy_purge_data
        policy_purge_data()
        
    elif command in ("download-met-office-data"):
        download_met_office_data()
        
    else:
        sys.stderr.write("ERROR: unrecognized command \"{0}\"\n".format(command))
        sys.exit(1)


# Local Variables:
# mode: python
# End:
