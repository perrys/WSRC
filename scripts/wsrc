#!/usr/bin/env python
# -*- coding: utf-8 -*-

import getopt
import logging
import os
import os.path
import sys

import wsrc.site.settings.settings as settings  
from wsrc.utils import sync_utils
import wsrc.utils.timezones as timezone_utils
LOGGER = logging.getLogger(__name__)

def make_username(csv_record):
  return "_".join([csv_record["firstname"].lower(), csv_record["surname"].lower()])

def persist_member_details(csv_record):
  from wsrc.site.usermodel.models import User
  user = User(first_name=csv_record["firstname"],
              last_name=csv_record["surname"],
              email=csv_record["email"],
              is_active=csv_record["active"],
              username=make_username(csv_record)
              )
  user.save()
  user.set_password(settings._WSRC_SETTINGS["default_pw"])
  user.save()
  user.player.cell_phone=csv_record["mobile_phone"]
  user.player.other_phone=csv_record["home_phone"]
  user.player.prefs_receive_email=csv_record["Data Prot email"]
  user.player.membership_id=csv_record["cardnumber"]
  user.player.membership_type=csv_record["category"]
  user.player.save()

def add_former_member(csv_filename, first, last):

  csv_records = sync_utils.parse_csv(csv_filename)
  csv_records = sync_utils.BooleanFieldWrapper.wrap_records(csv_records, "active")

  records = [r for r in csv_records if r["firstname"] == first and r["surname"] == last]
  if len(records) == 0:
    raise Exception("Could not find record of %(first)s %(last)s" % locals())
  if len(records) > 1:
    nrecords = len(records)
    raise Exception("Expected one record of %(first)s %(last)s, got %(nrecords)d" % locals())

  persist_member_details(records[0])

def manage_tournament_bookings(username, password):

  ADVANCE_BOOKING_DAYS = 10
  RELEASE_BOOKING_DAYS = 5
  TARGET_TIME          = datetime.time(19, 0)
  TARGET_DAYS          = [0,1,2,3] # monday - thursday
  TARGET_COURT         = 1
  TARGET_DESCRIPTION   = "Unreserved - will be released 5 days in advance"
  TARGET_NAME          = "Tournament Matches"

  today = datetime.today()
  target_date = today + datatime.timedelta(days=ADVANCE_BOOKING_DAYS)
  from wsrc.external_sites.booking_manager import BookingSystemSession
  session = BookingSystemSession(username, password)
  if target_date.weekday() in TARGET_DAYS:
    time = datetime.datetime.combine(target_date, TARGET_TIME)
    LOGGER.info("Booking tournament court @ {1}".format(time.isoformat))  
    session.make_booking(time, TARGET_COURT, TARGET_DESCRIPTION, TARGET_NAME)

  booking_events = get_booked_courts(session)
  for evt in booking_events:
    ndays = evt.time.date() - target_date
    if ndays < RELEASE_BOOKING_DAYS:
      if evt.name.lower().find("tournament") >= 0:
        if evt.description.lower().find("unreserved") >= 0:
          LOGGER.info("deleting booking id {0}, time: {1}, name: \"{2}\", description: \"{3}\"".format(evt.get_booking_id(), 
                                                                                                       evt.time.isoformat(" "), 
                                                                                                       evt.name, 
                                                                                                       evt.description))
          session.delete_booking(evt.get_booking_id())

import csv, codecs, cStringIO
class UnicodeWriter:
    """
    A CSV writer which will write rows to CSV file "f",
    which is encoded in the given encoding.
    """

    def __init__(self, f, dialect=csv.excel, encoding="utf-8", **kwds):
        # Redirect output to a queue
        self.queue = cStringIO.StringIO()
        self.writer = csv.writer(self.queue, dialect=dialect, **kwds)
        self.stream = f
        self.encoder = codecs.getincrementalencoder(encoding)()

    def writerow(self, row):
        self.writer.writerow([s.encode("utf-8") for s in row])
        # Fetch UTF-8 output from the queue ...
        data = self.queue.getvalue()
        data = data.decode("utf-8")
        # ... and reencode it into the target encoding
        data = self.encoder.encode(data)
        # write to the target stream
        self.stream.write(data)
        # empty queue
        self.queue.truncate(0)

    def writerows(self, rows):
        for row in rows:
            self.writerow(row)
  
def print_tournament_entrant_sheet():
  import wsrc.site.usermodel.models as user_models
  import wsrc.site.competitions.models as comp_models
  import wsrc.site.competitions.tournament as tournament_utils
  import wsrc.utils.collection_utils as collection_utils
  current_tournaments = [c for c in tournament_utils.get_current_competitions()]
  current_tournaments.sort(key=lambda(x): x.name)
  player_to_tournament_map = {}
  for tournament in current_tournaments:
    for entrant in tournament.entrant_set.all():
      collection_utils.get_or_add(player_to_tournament_map, entrant.player).append(tournament)
      if entrant.player2 is not None:
        collection_utils.get_or_add(player_to_tournament_map, entrant.player2).append(tournament)
  players = player_to_tournament_map.keys()
  players.sort(key=user_models.Player.get_full_name)
  header = ["Name"]
  header.extend([t.name for t in current_tournaments])
  rows = [header]
  for player in players:
    row = [player.get_full_name()]
    for tournament in current_tournaments:
      row.append(tournament in player_to_tournament_map[player] and "Y" or "")
    rows.append(row)
  writer = UnicodeWriter(sys.stdout)
  writer.writerows(rows)

def email_tournament_match_reminders(usernames):
  import markdown
  import wsrc.site.competitions.models as comp_models;
  import wsrc.site.competitions.tournament as tournament_utils
  import wsrc.site.models as site_models;
  import wsrc.site.usermodel.models as user_models;
  import wsrc.utils.collection_utils as collection_utils
  import wsrc.utils.email_utils as email_utils
  from django.template import Template, Context
  from wsrc.utils.text import formatTable as format_text_table
  from wsrc.utils.html_table import formatTable as format_html_table

  current_tournaments = tournament_utils.get_current_competitions()

  # Populate map of player_id -> unplayed matches
  player_to_matches_map = {}
  for tournament in current_tournaments:
    for m in tournament_utils.get_unplayed_matches(tournament):
      for i in [1,2]:
        for j in [1,2]:
          player = getattr(m, "team%(i)d_player%(j)d" % locals())
          if player is not None:
            match_list = collection_utils.get_or_add(player_to_matches_map, player.id)
            match_list.append(m)

  def get_opponent_desc(match, other_team_number, opponent_set=None):
    opponents = tournament_utils.get_players(match, other_team_number, opponent_set)
    if opponents is None:
      return None
    return " & ".join([p.get_full_name() for p in opponents])

  def get_previous_match_opponent_desc(match, other_team_number):
    previous_match = tournament_utils.get_previous_match(match, other_team_number)
    t1 = get_opponent_desc(previous_match, 1)
    t2 = get_opponent_desc(previous_match, 2)
    return "(WINNER of %(t1)s vs %(t2)s)" % locals()

  # for each player/match_list combination, create rectangular tables
  # of match descriptions and opponent details
  player_to_opponent_table_map = dict()
  player_to_match_table_map = dict()
  for player_id, match_list in player_to_matches_map.iteritems():
    player = user_models.Player.objects.get(pk=player_id)
    match_rows = [["Comp [Round]", "Opponent(s)", "Deadline", "Link"]]
    opponent_set = set()
    for match in match_list:
      my_team_number = tournament_utils.get_team_number(match, player_id)
      other_team_number = tournament_utils.other_team_number(my_team_number)
      opponent_desc = get_opponent_desc(match, other_team_number, opponent_set)
      if opponent_desc is None:
        try:
          opponent_desc = get_previous_match_opponent_desc(match, other_team_number)
        except comp_models.Match.DoesNotExist: # if opponents are two rounds behind
          opponent_desc = "(PREVIOUS MATCH UNRESOLVED)"
      comp_round = tournament_utils.get_round_for_match(match)
      nrounds = len(comp_round.competition.rounds.all())
      def rnd():
        n = 1+nrounds-comp_round.round
        if n == 1:
          return "F"
        if n == 2:
          return "SF"
        if n == 3:
          return "QF"
        return str(n)
      match_rows.append([match.competition.name + " [" + rnd() + "]", opponent_desc, comp_round.end_date.strftime("%a %d %b"), match.competition.url])
    opponent_rows = [["Name", "Email", "Telephone", "Mobile"]]
    for opponent_id in opponent_set:
      opponent = user_models.Player.objects.get(pk=opponent_id)
      opponent_rows.append([opponent.get_full_name(), opponent.user.email, opponent.other_phone, opponent.cell_phone]) 
    player_to_match_table_map[player_id] = match_rows
    player_to_opponent_table_map[player_id] = opponent_rows

  # now iterate over the players and construct emails using these tables
  email_template = site_models.EmailContent.objects.get(name="Tournament Reminder")
  email_template = Template(email_template.markup)
  failed_players = []
  for player_id in player_to_match_table_map.iterkeys():
    p = user_models.Player.objects.get(pk=player_id)
    match_table = player_to_match_table_map[player_id]
    opponent_table = player_to_opponent_table_map[player_id]
    context = Context({
      "player": p,
      "match_table": {
        "raw_data": match_table,
        "text/plain": format_text_table(match_table, hasHeader=True, nspaces=2),
        "text/html":  format_html_table(match_table, hasHeader=True),
        },
      "opponent_table": {
        "raw_data":   opponent_table,
        "text/plain": format_text_table(opponent_table, hasHeader=True, nspaces=2),
        "text/html":  format_html_table(opponent_table, hasHeader=True, col_prefixes=["", "mailto:", "tel:", "sms:"]),
        },
      "content_type": "text/html"
      })
    if usernames == [] or p.user.username in usernames:
      if p.user.email.find('@') > 0:
        subject = "2015 Tournaments"
        from_address = "tournaments@wokingsquashclub.org"
        html_body = markdown.markdown(email_template.render(context))
        context["content_type"] = "text/plain"
        text_body = email_template.render(context)
        to_list = [p.user.email]
        try:
          print "\n*** " + p.user.email
          sys.stdout.flush()
          email_utils.send_email(subject, text_body, html_body, from_address, to_list)
        except:
          failed_players.append(p)
          import traceback
          traceback.print_exc()
        email_utils.pause_between_emails()
      else:
        sys.stderr.write("WARNING: no email address for " + p.get_full_name())
    else:
      context["content_type"] = "text/plain"
      print "\n*** " + p.user.email + "\n"
      print email_template.render(Context(context)).encode('utf-8')
    if len(failed_players) > 0:
      sys.stderr.write("ERROR: failed to send email to the following:\n" + "\n".join([p.get_full_name() + " " + p.user.email for p in failed_players]) + "\n")

def email_membership(argv):
  import wsrc.utils.email_utils as email_utils
  def usage():
    prog = os.path.basename(argv[0])
    sys.stderr.write("USAGE: %s %s --subject <subject> --messagefile <filename> --from <email_address> [--filter <member_type1>,<member_type2>..] [--test_email] [--noconfirm]\n" % (prog, argv[1]))
  try:
    optlist, args = getopt.getopt(argv[2:], "s:m:f:", ["subject=", "messagefile=", "filter=", "from=", "test_email=", "noconfirm"])
  except getopt.GetoptError as err:
    sys.stderr.write(str(err) + "\n")
    usage()
    sys.exit(2)
    
  subject = messagefile = from_address = member_types = test_email = None
  noconfirm = False
  for opt,val in optlist:
    if opt in ["-s", "--subject"]:
      subject = val
    elif opt in ["-m", "--messagefile"]:
      messagefile = val
    elif opt in ["-f", "--from"]:
      from_address = val
    elif opt in ["--filter"]:
      member_types = val
    elif opt in ["--test_email"]:
      test_email = val
    elif opt in ["--noconfirm"]:
      noconfirm = True
    else:
      assert False, "unhandled option"
  if subject is None or messagefile is None or from_address is None:
    usage()
    sys.exit(2)

  fh = open(os.path.expanduser(messagefile))
  message = fh.read()
  fh.close()
  
  if test_email is not None:
    from wsrc.site.usermodel.models import Player
    member_list = [Player.objects.get(user__email=email) for email in test_email.split(",")]
  else:
    if member_types is not None:
      member_types = member_types.split(",")
    member_list = email_utils.select_members(member_types)
    
  if not noconfirm:
    sys.stdout.write("About to email %d member(s), are you sure [y/N]: " % len(member_list))
    line = sys.stdin.readline()
    if not line.lower().startswith("y"):
      sys.exit(0)
  
  success_list = email_utils.bulk_email_membership(subject, message, from_address, member_list)
  print "Emailed %d members" % len(success_list)
  
def sync_membership_records(csv_filename):

  from wsrc.site.usermodel.models import Player, User

  def is_valid_member_predicate(record):
    return (len(record["surname"].strip()) > 0) and \
        not "2099" in record["joiningdate"] and \
        record["active"].lower()[0] == "y" 

  csv_records = sync_utils.parse_csv(csv_filename)
  csv_records = [r for r in csv_records if is_valid_member_predicate(r)]
  csv_records = sync_utils.FieldJoiningWrapper.wrap_records(csv_records, "name", ["firstname", "surname"], " ")
  csv_records = sync_utils.BooleanFieldWrapper.wrap_records(csv_records, "active")
  csv_records = sync_utils.BooleanFieldWrapper.wrap_records(csv_records, "Data Prot email")
  csv_records = sync_utils.IntegerFieldWrapper.wrap_records(csv_records, "cardnumber")
  translations = {
    "complimenrtary": "compl",
    "complementary":  "compl",
    "non-playing":    "non_play",
    "off-peak":       "off_peak",
    "young adult":    "y_adult",
    }
  csv_records = sync_utils.LowerCaseFieldWrapper.wrap_records(csv_records, "category")
  csv_records = sync_utils.ValueTranslatingFieldWrapper.wrap_records(csv_records, "category", **translations)

  db_records = sync_utils.ModelRecordWrapper.wrap_queryset(Player.objects.all())
  db_records = sync_utils.FieldMappingWrapper.wrap_records(db_records, 
                                                           name="get_full_name", 
                                                           email="user.email", 
                                                           mobile_phone="cell_phone",
                                                           home_phone="other_phone",
                                                           cardnumber="membership_id",
                                                           category="membership_type",
                                                           active="user.is_active")
  for f in db_records:
    f.field_mapping["Data Prot email"] = "prefs_receive_email"


  comparison_fields = ["email", "mobile_phone", "home_phone", "active", "cardnumber", "category", "Data Prot email"]
  lhsonly, rhsonly, diffs  = sync_utils.report_differences(db_records, csv_records, "name", comparison_fields)

  print "\n*** Members only in db:"
  for record in lhsonly:
    if not record["user.is_active"]:
      continue
    print record["name"]
    def is_invalid_member_predicate(record):
      return (len(record["surname"].strip()) > 0) and \
          not "2099" in record["joiningdate"] and \
          record["active"].lower()[0] != "y" 
    invalid_csv_records = [r for r in sync_utils.parse_csv(csv_filename) if is_invalid_member_predicate(r)]
    invalid_csv_records = sync_utils.FieldJoiningWrapper.wrap_records(invalid_csv_records, "name", ["firstname", "surname"], " ")
    for r in invalid_csv_records:
      if r["name"] == record["get_full_name"]:
        if settings._WSRC_SETTINGS["sync_updates"]:
          print "Invalidating: " + r["name"]
          player_record = Player.objects.get(pk=record["id"])
          player_record.user.is_active = False
          player_record.user.save()
        else:
          print "Should mark invalid: " + r["name"]
        break

  print "\n*** Members only in CSV file:"
  for record in rhsonly:
    existing_player = None
    try:
      if record["cardnumber"] is not None:
        existing_player = Player.objects.get(membership_id=int(record["cardnumber"]))
        print existing_player
    except Player.DoesNotExist:
      pass
    if existing_player is not None:
      continue
    print record["name"]
    possibles = Player.objects.filter(user__last_name__iexact=record["surname"])
    if len(possibles) > 0:
      print " possibles: " + str(possibles)

    # update the DB with new members if necessary:
    if settings._WSRC_SETTINGS["sync_updates"]:
      username="_".join([record["firstname"].lower(), record["surname"].lower()])
      # skip usernames in DB already - can arise when translating unicode names to ascii usernames 
      matches = User.objects.filter(username=username) 
      if len(matches) == 0:
        persist_member_details(record)

  print "\n*** Record differences:"
  for name,v in diffs.iteritems():
    diff, record, csv_record = v
    player = record.target.record
    print player, diff
    if settings._WSRC_SETTINGS["sync_updates"]:
      for field,vals in diff.iteritems():
        def testAndSetField(csv_field, db_record, db_field):
          if field == csv_field:
            setattr(db_record, db_field, vals[1])
        testAndSetField("mobile_phone",    player, "cell_phone")
        testAndSetField("home_phone",      player, "other_phone")
        testAndSetField("email",           player.user, "email")
        testAndSetField("cardnumber",      player, "membership_id")
        testAndSetField("category",        player, "membership_type")
        testAndSetField("Data Prot email", player, "prefs_receive_email")
        
      player.save()
      player.user.save()

if __name__ == "__main__":
  prog = os.path.basename(sys.argv[0])

  if len(sys.argv) < 2:
    sys.stderr.write("USAGE: %(prog)s <command> [arguments]\n" % locals())
    sys.exit(1)

  os.environ.setdefault("DJANGO_SETTINGS_MODULE", "wsrc.site.settings.settings")
  logging.basicConfig(format='%(asctime)-10s [%(levelname)s] %(message)s',datefmt="%Y-%m-%d %H:%M:%S")

  import django
  if hasattr(django, "setup"):
    django.setup()

  import wsrc.external_sites.main

  command = sys.argv[1]
  args = sys.argv[2:]
  if command in ("sync", "sync-bookings"):
    wsrc.external_sites.main.cmdline_sync_bookings()

  elif command in ("sync-squashlevels"):
    wsrc.external_sites.main.cmdline_sync_squashlevels(*args)

  elif command in ("sync-leaguemaster"):
    wsrc.external_sites.main.cmdline_sync_leaguemaster(*args)

  elif command in ("sync-membership"):
    sync_membership_records(args[0])

  elif command in ("email-membership"):
    email_membership(sys.argv)

  elif command in ("manage-tournament-bookings"):

    def usage():
      prog = os.path.basename(argv[0])
      sys.stderr.write("USAGE: %s %s --username=<user> --password=<pw>\n" % (prog, argv[1]))
    try:
      optlist, args = getopt.getopt(argv[2:], "u:p:h", ["username=", "password="])
    except getopt.GetoptError as err:
      sys.stderr.write(str(err) + "\n")
      usage()
      sys.exit(2)
      
    username = password = None
    for opt,val in optlist:
      if opt in ["-u", "--username"]:
        useranme = val
      elif opt in ["-p", "--password"]:
        password = val
      elif opt in ["-h"]:
        usage()
        sys.exit(0)
      else:
        assert False, "unhandled option"
      
    if username is None or password is None:
      usage()
      sys.exit(1)

    manage-tournament-bookings(username, password)

  elif command in ("print-tournament-sheet"):
    print_tournament_entrant_sheet()

  elif command in ("send-tournament-reminders"):
    def usage():
      sys.stderr.write("USAGE: %s %s --username <username>|--all\n" % (prog, command))
    try:
      optlist, args = getopt.getopt(sys.argv[2:], "au:", ["all", "username="])
    except getopt.GetoptError as err:
      sys.stderr.write(str(err) + "\n")
      usage()
      sys.exit(2)

    user_list = None
    for opt,val in optlist:
      if opt in ["-a", "--all"]:
        user_list = []
      elif opt in ["-u", "--username"]:
        user_list = [val]

    if user_list is None:
      usage()
      sys.exit(2)

    email_tournament_match_reminders(user_list)

  elif command in ("add-old-league"):
    wsrc.external_sites.main.cmdline_add_old_league(args[0])

  elif command in ("add-former-member"):
    add_former_member(args[0], args[1], args[2])

            

# Local Variables:
# mode: python
# End:
